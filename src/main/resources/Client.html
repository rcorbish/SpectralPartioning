<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Laplace</title>
<link rel="stylesheet" href="index.css">
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>

</head>
<body>

	<div id="canvas-3d"></div>
	<canvas id="canvas-2d-vals"></canvas>
	<canvas id="canvas-2d-vect"></canvas>
	<canvas id="canvas-2d-clus"></canvas>

	<script>
		const MESH_SIZE = 300 ;
		
		var responseMessage  ;

		var scene;
		var camera;
		var controls;
		var renderer;
		var mesh;
		var texture;
		var sortEigenvectors = false ;
		var eigenvalueIndex = 5 ;

		
		const material = new THREE.MeshStandardMaterial({
			side : THREE.DoubleSide,
			opacity : 1.0,
			color : 0xffffff,
			wireframe : false,
			metalness : 0.65,
			roughness : 0.3
		});
		
		const canvas3d = document.getElementById("canvas-3d");
		const canvas2dVals = document.getElementById("canvas-2d-vals");
		const canvas2dVect = document.getElementById("canvas-2d-vect");
		const canvas2dClus = document.getElementById("canvas-2d-clus");

		function processData() {
			if (this.status === 200) {
				responseMessage = JSON.parse(this.responseText);
				
				let geometry = new THREE.ParametricBufferGeometry(
						graphFunction, MESH_SIZE, MESH_SIZE );

				if( !mesh ) {
					mesh = new THREE.Mesh(geometry, material);
					scene.add( mesh ) ;
				} else {
					mesh.geometry = geometry ;
				}

				canvas3d.width = canvas3d.width ;

				render() ;
				
				plotValues() ;
				plotVector() ;
				plotCluster() ;
			}
		}

		const xhr = new XMLHttpRequest();
		xhr.addEventListener("load", processData);

		function getData() {
			xhr.open("GET", "/data/" + eigenvalueIndex ) ;
			xhr.send();
		}

		var clientWidth  ;
		var clientHeight ;

		function resize() {
			clientWidth = window.innerWidth / 2 ;
			clientHeight = window.innerHeight / 2 ;
			
			canvas3d.width = clientWidth ;
			canvas3d.height = clientHeight ;
			
			canvas2dVals.width = clientWidth ;
			canvas2dVals.height = clientHeight ;

			canvas2dVect.width = clientWidth ;
			canvas2dVect.height = clientHeight ;

			canvas2dClus.width = clientWidth ;
			canvas2dClus.height = clientHeight ;

			camera.aspect = clientWidth / clientHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(clientWidth, clientHeight);
			getData();
		}

		window.addEventListener("resize", function() {
			resize();
		});

		window.addEventListener("load", function() {
			
			canvas2dVect.addEventListener('click', function() {
				sortEigenvectors = !sortEigenvectors ;
				if( !sortEigenvectors ) {
					sortOrder = null ; 
				}
				plotVector() ;
				plotCluster() ;
			});
			
			canvas2dVals.addEventListener('click', function(evt) {
				var x = evt.offsetX  ;
				const w = clientWidth - 50 ;
				x = ( x - 25 ) * responseMessage.eigenvalues.length / w ; 
				eigenvalueIndex = Math.floor( x ) ;
				
				if( eigenvalueIndex<0 ) eigenvalueIndex = 0 ;
				if( eigenvalueIndex>=responseMessage.eigenvalues.length ) eigenvalueIndex=responseMessage.eigenvalues.length -1 ;
				getData() ;
			});

			init();
			resize();
			animate();
		});

		
		function graphFunction(u, v) {
			if( !responseMessage ) return new THREE.Vector3(0,0,0);
			
			let c = Math.floor( u * (responseMessage.N-1) ) ;
			let r = Math.floor( v * (responseMessage.N-1) ) ;
			
			let y = clientHeight 
					* responseMessage.surface[ c*responseMessage.N + r ] 
					- clientHeight / 2;

			let z = v * clientWidth - clientWidth / 2;
			let x = u * clientWidth - clientWidth / 2;
			
			return new THREE.Vector3(x, y, z);
		}



		function init() {

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(75, window.innerWidth
					/ window.innerHeight, 1, 10000);
			camera.position.z = 1200;

			const light1 = new THREE.AmbientLight(0xffffff, .2);
			scene.add(light1);

			const light2 = new THREE.DirectionalLight(0xff0000, 1.0);
			light2.position.set(1000, 1700, 0);
			scene.add(light2);

			const light3 = new THREE.DirectionalLight(0x0000ff, 1.0);
			light3.position.set(-1000, 1700, 0);
			scene.add(light3);

			renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);

			canvas3d.appendChild(	renderer.domElement ) ;

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.addEventListener('change', render);
		}

		function animate() {
			requestAnimationFrame(animate);
			controls.update();
		}

		function render() {
			renderer.render(scene, camera);
		}
		
		
		function plotValues() {
		
			canvas2dVals.width = canvas2dVals.width ;

			if( !responseMessage || responseMessage.eigenvalues.length==0 ) return ;

			const h = clientHeight - 50 ;
			const w = clientWidth - 50 ;
			
			let mn = responseMessage.eigenvalues[0] ;
			let mx = mn ;
			
			for( let i=1 ; i<responseMessage.eigenvalues.length ; i++ ) {
				mn = Math.min( responseMessage.eigenvalues[i], mn ) ;
				mx = Math.max( responseMessage.eigenvalues[i], mx ) ;				
			}
			const range = mx - mn ;
			
			const ctx=canvas2dVals.getContext("2d") ;
			
			var y = h - ( ( responseMessage.eigenvalues[0] - mn ) / range * h ) ;
			var x = 0 ;
			
			ctx.beginPath();
			ctx.strokeStyle="#2060a0" ;
			ctx.lineWidth = 2 ;
			ctx.moveTo( x+25, y+25 );
			
			for( let i=1 ; i<responseMessage.eigenvalues.length ; i++ ) {
				y = h - ( ( responseMessage.eigenvalues[i] - mn ) / range * h ) ;
				x = ( i / responseMessage.eigenvalues.length ) * w ;				
				ctx.lineTo( x+25, y+25 );
			}
			ctx.stroke();
			
			ctx.beginPath();
			ctx.fillStyle="#3060a0" ;

			if( eigenvalueIndex >= 0 ) {
				y = h - ( ( responseMessage.eigenvalues[eigenvalueIndex] - mn ) / range * h ) ;
				x = ( eigenvalueIndex / responseMessage.eigenvalues.length ) * w ;
				ctx.arc(x+25,y+25,5,0,2*Math.PI);
			}
			ctx.fill();
		}

		
		
		var sortOrder = null ;
		function plotVector() {
		
			canvas2dVect.width = canvas2dVect.width ;

			if( !responseMessage || responseMessage.eigenvectors.length==0 ) return ;

			const h = clientHeight - 50 ;
			const w = clientWidth - 50 ;
/*
			var st = eigenvalueIndex - 5 ;
			if( st<0 ) st = 0 ;
			if( st>=responseMessage.N ) st = responseMessage.N - 11 ;  
			var ed = st + 10 ;
*/
			var st = 0 ;
			var ed = 10 ;
			let mn = responseMessage.eigenvectors[responseMessage.N*st] ;
			let mx = mn ;
			
			for( let i=st ; i<ed ; i++ ) {
				for( let j=0 ; j<responseMessage.N; j++ ) {
					mn = Math.min( responseMessage.eigenvectors[responseMessage.N*i+j], mn ) ;
					mx = Math.max( responseMessage.eigenvectors[responseMessage.N*i+j], mx ) ;
				}
			}
			const range = mx - mn ;
			
			const ctx=canvas2dVect.getContext("2d") ;
			
			var color = 0x603020 ;

			// get selected eigenvector
			var tmp = responseMessage.eigenvectors.slice( eigenvalueIndex, eigenvalueIndex+responseMessage.N  )
			if( sortEigenvectors ) {
				sortOrder = tmp.map( function(e,i) { return {x:e, i:i } ; } )
				  .sort( function(a, b){return a.x-b.x} ) 
				  .map( function(e) { return e.i ; } ) ;
			} else {
				sortOrder = [] ;
				for( let i=0 ; i<responseMessage.N ; i++ ) {
					sortOrder[i] = i ;
				}
			} 

			
			for( let n=st ; n<ed ; n++ ) {

				const start = responseMessage.N * n ;
				var data = responseMessage.eigenvectors
							.slice( start, start+responseMessage.N  )
							;
				if( sortEigenvectors ) {
					data = data.map( function(e,i) { return {x:e, i:i } ; } ) 
							   .sort( function(a, b){return a.x-b.x} ) 
							   .map( function(e) { return e.x ; } ) ;					
				} 
				
				var x = 0 ;
				var y = h - ( ( data[0] - mn ) / range * h ) ;
				
				color += 0x806020 ;
				let cc = "000000" + color.toString(16) ;
				
				ctx.beginPath();
				ctx.strokeStyle="#" + cc.substring( cc.length-8 ) ;
				ctx.lineWidth = 1 ;
				ctx.moveTo( x+25, y+25 );

				for( let i=1 ; i<data.length ; i++ ) {
					x = ( i / responseMessage.N ) * w ;				
					y = h - ( ( data[i] - mn ) / range * h ) ;
					ctx.lineTo( x+25, y+25 );
				}
				ctx.stroke();
				
			}
		}

		
		function plotCluster() {
		
			canvas2dClus.width = canvas2dClus.width ;

			if( !sortOrder || !responseMessage || responseMessage.eigenvectors.length==0 ) return ;

			var N = responseMessage.N ;

			let mn = responseMessage.surface[0] ;
			let mx = mn ;
			for ( let i=1 ; i<(N*N) ; i++ ) {
				mn = Math.min( responseMessage.surface[i], mn ) ;
				mx = Math.max( responseMessage.surface[i], mx ) ;				
			}
			const range = mx - mn ;

			const h = clientHeight - 50 ;
			const w = clientWidth - 50 ;
			
			const ctx=canvas2dClus.getContext("2d") ;
			const pixelH = Math.ceil( h / responseMessage.N ) ;
			const pixelW = Math.ceil( w / responseMessage.N ) ;
			
			const pixelImage = ctx.createImageData(pixelW,pixelH); 
			const pixelData = pixelImage.data;
			
			for( let pc=0 ; pc<pixelH ; pc++ ) {
				for( let pr=0 ; pr<pixelW ; pr++ ) {
					let ix = 4 * ( pc*pixelW + pr ) ;
					pixelData[ix+3] = 0xff ;
				}
			}
			
			ctx.beginPath();

			
			for ( let c=0, ix=0 ; c<N ; c++ ) {
				let sc = sortOrder[c] ;
				x = ( c / N ) * w ;				
				for ( let r=0 ; r<N ; r++, ix++ ) {
					y = ( r / N ) * h ;

					let sr = sortOrder[r] ;
					let val = responseMessage.surface[sc*N+sr] ;
					if( val === 0 ) continue ;
					
					let normalizedVal = ( val - mn ) / range ;
					let color = 0xffffff * normalizedVal ;					
					
					let rr = ( 0xff0000 & color ) >> 16 ; 					
					let gg = ( 0xff00 & color ) >> 8 ; 					
					let bb = ( 0xff & color ) ;
					
					for( let pc=0 ; pc<pixelH ; pc++ ) {
						for( let pr=0 ; pr<pixelW ; pr++ ) {
							let ix = 4 * ( pc*pixelW + pr ) ;
							pixelData[ix+0] = rr ;
							pixelData[ix+1] = gg ;
							pixelData[ix+2] = bb ;
						}
					}
					
					ctx.putImageData( pixelImage, x+25, y+25 ) ;
				}
			}
		}

	</script>


</body>
</html>